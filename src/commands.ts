import * as vscode from 'vscode';
import * as gpt from "./gpt";
import * as vsc from "./vsc_interaction";

const INPUT_BOX = 1;

/**
 * Represents a VSC extension executable command.
 */
abstract class ExecutableCommand {
    /**
     * Asynchronous method to execute command actions.
     * Implemented by subclasses.
     */
    abstract execute(): Promise<void>;
}

/**
 * Represents a VSC extension command that sends a prompt to a LLM
 * and shows the answer to the user in the active text editor.
 */
abstract class BaseTextEditorCommand extends ExecutableCommand {
    async askLLM(prompt: string): Promise<string> {
        try {
            vscode.window.showInformationMessage("Asking GPT...");
            const answer = await this.getLLMAnswerMethod(prompt);
            return answer;
        } catch (error) {
            vscode.window.showErrorMessage("Could not get response from OpenAI.");
            return "";
        }
    }

    async handleAnswer(editor: vscode.TextEditor, answer: string) {
        if (answer !== "") {
            this.onSuccess(editor, answer);
        }
    }

    /**
     * This method is called once the answer is successfully obtained from the
     * LLM model.
     */
    async onSuccess(editor: vscode.TextEditor, answer: string) {
        this.showAnswer(editor, answer);
        vscode.window.showInformationMessage("Answer created.");
    }

    /**
     * Gets the answer generated by the LLM.
     * To be implemented by the subclasses.
     */
    abstract getLLMAnswerMethod(prompt: string): Promise<string>;

    /**
     * Shows the answer generated by the LLM.
     * To be implemented by the subclasses.
     */
    abstract showAnswer(editor: vscode.TextEditor, answer: string): Promise<void>;

    /**
     * Creates a prompt for the LLM based on the given input code and optional user input.
     * To be implemented by the subclasses.
     *
     * @param inputCode - The code to be used as context for the query.
     * @param userInput - Optional string representing any additional user input or instructions.
     * @return A string containing the LLM prompt.
     */
    abstract createPrompt(inputCode: string, userInput?: string): string;
}

abstract class BaseWithNoUserInputCommand extends BaseTextEditorCommand {
    async execute() {
        const [editor, inputCode] = vsc.startCommandForTextEditor();
        const prompt = this.createPrompt(inputCode);
        const answer = await this.askLLM(prompt);
        this.handleAnswer(editor, answer);
    }

    createPrompt(inputCode: string): string {
        return inputCode;
    }
}

abstract class BaseWithUserInputCommand extends BaseTextEditorCommand {
    async execute() {
        const [editor, inputCode] = vsc.startCommandForTextEditor();
        const userInput = await this.getUserInput();

        if (!userInput) {
            return;
        }

        const prompt = this.createPrompt(inputCode, userInput);
        const answer = await this.askLLM(prompt);
        await this.handleAnswer(editor, answer);
    }
    
    async getUserInput(): Promise<string | undefined> {
        const userInput = await vscode.window.showInputBox();

        if (userInput === undefined) {
            vscode.window.showErrorMessage("Enter your prompt.");
        }

        return userInput;
    }

    createPrompt(inputCode: string, userInput: string): string {
        return `Code:\n\`\`\`${inputCode}\n\`\`\`\n${this.writeUserInputForPrompt(userInput)}`;
    }

    /**
     * Formats the user input as part of the LLM prompt.
     * To be implemented by the subclasses.
     *
     * @param userInput - The user input to be formatted.
     * @return A string containing the formatted user input for the LLM prompt.
     */
    abstract writeUserInputForPrompt(userInput: string): string;
}

export class AutocodeCommand extends BaseWithNoUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        return gpt.getGptAutocode(prompt);
    }

    async showAnswer(editor: vscode.TextEditor, answer: string) {
        editor.edit(editBuilder => {
            const position = editor.selection.active;
            editBuilder.insert(position, answer);
        });
    }
}

export class AutorunCommand extends BaseWithNoUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        return gpt.getGptAutorun(prompt);
    }

    async showAnswer(editor: vscode.TextEditor, answer: string) {
        vsc.showGPTAnswer(answer);
    }
}

export class AskProblemCommand extends BaseWithUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        return gpt.getGptAskProblem(prompt);
    }

    async showAnswer(editor: vscode.TextEditor, answer: string) {
        editor.edit(editBuilder => {
            const position = editor.selection.active;
            editBuilder.insert(position, answer);
        });
    }
    
    writeUserInputForPrompt(userInput: string): string {
        return `Question:\n"${userInput}".`;
    }
}


export class AutochangeCommand extends BaseWithUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        return gpt.getGptAutochange(prompt);
    }

    async showAnswer(editor: vscode.TextEditor, answer: string): Promise<void> {
        vsc.showGPTAnswer(answer);
    }

    writeUserInputForPrompt(userInput: string): string {
        return `Change this:\n"${userInput}".`;
    }
}

export class ExplainCommand extends BaseWithUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        return gpt.getGptExplain(prompt);
    }

    async showAnswer(editor: vscode.TextEditor, answer: string): Promise<void> {
        vsc.showGPTAnswer(answer);
    }

    writeUserInputForPrompt(userInput: string): string {
        return `User says:\n"${userInput || 'Explain this code'}".`;
    }
}

export class AskFreeCommand extends BaseWithUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        return gpt.getGptAskFree(prompt);
    }

    async showAnswer(editor: vscode.TextEditor, answer: string): Promise<void> {
        vsc.showGPTAnswer(answer);
    }

    writeUserInputForPrompt(userInput: string): string {
        return `User says:\n"${userInput}".`;
    }
}

export class AutorunExampleCommand extends BaseWithNoUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        return gpt.getGptAutorunExample(prompt);
    }

    async showAnswer(editor: vscode.TextEditor, answer: string) {
        vsc.showGPTAnswer(answer);
    }
}

export class AutorunSequenceCommand extends BaseWithNoUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        return gpt.getGptAutorunSequence(prompt);
    }

    async showAnswer(editor: vscode.TextEditor, answer: string) {
        vsc.showGPTAnswer(answer);
    }
}

export class EsotericCommand extends BaseWithNoUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        return gpt.getGptEsoteric(prompt);
    }

    async showAnswer(editor: vscode.TextEditor, answer: string) {
        vsc.showGPTAnswer(answer);
    }
}

export class RefactorizeCommand extends BaseWithNoUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        return gpt.getGptRefactorize(prompt);
    }

    async showAnswer(editor: vscode.TextEditor, answer: string) {
        vsc.showGPTAnswer(answer);
    }
}

export class DesignPatternsSuggestionsCommand extends BaseWithNoUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        return gpt.getGptDesignPatternsSugesttions(prompt);
    }

    async showAnswer(editor: vscode.TextEditor, answer: string) {
        vsc.showGPTAnswer(answer);
    }
}

export class DesignPatternCommand extends BaseWithUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        return gpt.getGptDesignPattern(prompt);
    }

    async showAnswer(editor: vscode.TextEditor, answer: string): Promise<void> {
        vsc.showGPTAnswer(answer);
    }

    writeUserInputForPrompt(userInput: string): string {
        return `Design pattern: ${userInput}.`;
    }
}