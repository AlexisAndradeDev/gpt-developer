import * as vscode from 'vscode';
import * as gpt from "./gpt";
import * as vsc from "./vsc_interaction";

const INPUT_BOX = 1;

/**
 * Represents a VSC extension executable command.
 */
abstract class ExecutableCommand {
    /**
     * Asynchronous method to execute command actions.
     * Implemented by subclasses.
     */
    abstract execute(): Promise<void>;
}

/**
 * Represents a VSC extension command that sends a prompt to a LLM
 * and shows the answer to the user in the active text editor.
 */
abstract class BaseTextEditorCommand extends ExecutableCommand {
    async askLLM(prompt: string): Promise<string> {
        try {
            vscode.window.showInformationMessage("Asking GPT...");
            const answer = await this.getLLMAnswerMethod(prompt);
            return answer;
        } catch (error) {
            vscode.window.showErrorMessage("Could not get response from OpenAI.");
            return "";
        }
    }

    async handleAnswer(editor: vscode.TextEditor, answer: string) {
        if (answer !== "") {
            this.onSuccess(editor, answer);
        } else {
            vscode.window.showErrorMessage("The LLM was unable to generate a successful response for this command.");
        }
    }

    /**
     * This method is called once the answer is successfully obtained from the
     * LLM model.
     */
    async onSuccess(editor: vscode.TextEditor, answer: string) {
        this.showAnswer(editor, answer);
        vscode.window.showInformationMessage("Answer created.");
    }

    /**
     * Gets the answer generated by the LLM.
     * To be implemented by the subclasses.
     */
    abstract getLLMAnswerMethod(prompt: string): Promise<string>;

    /**
     * Shows the answer generated by the LLM.
     * To be implemented by the subclasses.
     */
    abstract showAnswer(editor: vscode.TextEditor, answer: string): Promise<void>;

    /**
     * Creates a prompt for the LLM based on the given input code and optional user input.
     * To be implemented by the subclasses.
     *
     * @param inputCode - The code to be used as context for the query.
     * @param userInput - Optional string representing any additional user input or instructions.
     * @return A string containing the LLM prompt.
     */
    abstract createPrompt(inputCode: string, userInput?: string): string;
}

abstract class BaseWithNoUserInputCommand extends BaseTextEditorCommand {
    async execute() {
        const [editor, inputCode] = vsc.startCommandForTextEditor();
        const prompt = this.createPrompt(inputCode);
        const answer = await this.askLLM(prompt);
        this.handleAnswer(editor, answer);
    }

    createPrompt(inputCode: string): string {
        return inputCode;
    }
}

abstract class BaseWithUserInputCommand extends BaseTextEditorCommand {
    async execute() {
        const [editor, inputCode] = vsc.startCommandForTextEditor();
        const userInput = await this.getUserInput();

        if (!userInput) {
            return;
        }

        const prompt = this.createPrompt(inputCode, userInput);
        const answer = await this.askLLM(prompt);
        await this.handleAnswer(editor, answer);
    }
    
    async getUserInput(): Promise<string> {
        const userInput = await vscode.window.showInputBox();

        if (userInput === undefined) {
            vscode.window.showErrorMessage("Enter your prompt.");
            return "";
        }

        return userInput;
    }

    createPrompt(inputCode: string, userInput: string): string {
        console.log(inputCode, userInput);
        return `Code:\n\`\`\`${inputCode}\n\`\`\`\n${this.writeUserInputForPrompt(userInput)}`;
    }

    /**
     * Formats the user input as part of the LLM prompt.
     * To be implemented by the subclasses.
     *
     * @param userInput - The user input to be formatted.
     * @return A string containing the formatted user input for the LLM prompt.
     */
    abstract writeUserInputForPrompt(userInput: string): string;
}

export class AutocodeCommand extends BaseWithNoUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        var suggestion = await gpt.getGptSuggestion(
            prompt, 
            "You are a code auto-completion tool installed in Visual Studio Code as an extension. Given the input code and comments, generate new code (DO NOT rewrite the input code, just return the NEW one, unless the user asked to). Pay especial attention to the latest comment (if there's one). You ONLY give *code*.",
        );
        suggestion = gpt.getCodeFromModelSuggestion(suggestion);
        suggestion = gpt.cleanCodeAnswer(suggestion);
        return suggestion;
    }

    async showAnswer(editor: vscode.TextEditor, answer: string) {
        vsc.writeInVSC(editor, answer, vsc.WRITE_IN_ACTIVE_EDITOR);
    }
}

export class AutorunCommand extends BaseWithNoUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        var suggestion = await gpt.getGptSuggestion(
            prompt,
            "You are a debugging tool installed in Visual Studio Code as an extension. You are given a piece of code and you simulate how it would run, giving details about variables values, exceptions raised, bugs and information about runtime and compilation.",
        );
        return suggestion;
    }

    async showAnswer(editor: vscode.TextEditor, answer: string) {
        vsc.writeInVSC(editor, answer, vsc.WRITE_IN_SIDE_PANEL);
    }
}

export class AskProblemCommand extends BaseWithUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        var suggestion = await gpt.getGptSuggestion(
            prompt,
            "You are a debugging tool installed in Visual Studio Code as an extension. You are given a piece of code and are asked about a problem that piece of code is having/might have.",
        );
        return suggestion;
    }

    async showAnswer(editor: vscode.TextEditor, answer: string) {
        vsc.writeInVSC(editor, answer, vsc.WRITE_IN_SIDE_PANEL);
    }
    
    writeUserInputForPrompt(userInput: string): string {
        return `Question:\n"${userInput}".`;
    }
}

export class AutochangeCommand extends BaseWithUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        var suggestion = await gpt.getGptSuggestion(
            prompt,
            "You are a coding tool installed in Visual Studio Code as an extension. You are given a piece of code and are asked to change something on it. You ONLY give *code*.",
        );
        suggestion = gpt.getCodeFromModelSuggestion(suggestion);
        suggestion = gpt.cleanCodeAnswer(suggestion);
        return suggestion;
    }

    async showAnswer(editor: vscode.TextEditor, answer: string): Promise<void> {
        vsc.writeInVSC(editor, answer, vsc.WRITE_IN_SIDE_PANEL);
    }

    writeUserInputForPrompt(userInput: string): string {
        return `Change this:\n"${userInput}".`;
    }
}

export class ExplainCommand extends BaseWithUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        var suggestion = await gpt.getGptSuggestion(
            prompt,
            "You are a debugging tool installed in Visual Studio Code as an extension. You are given a piece of code and are asked to explain it.",
        );
        return suggestion;
    }

    async showAnswer(editor: vscode.TextEditor, answer: string): Promise<void> {
        vsc.writeInVSC(editor, answer, vsc.WRITE_IN_SIDE_PANEL);
    }

    writeUserInputForPrompt(userInput: string): string {
        return `User says:\n"${userInput || 'Explain this code'}".`;
    }
}

export class AskFreeCommand extends BaseWithUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        var suggestion = await gpt.getGptSuggestion(
            prompt,
            "You are a virtual assistant installed in Visual Studio Code as an extension to help in software development and programming tasks.",
        );
        return suggestion;
    }

    async showAnswer(editor: vscode.TextEditor, answer: string): Promise<void> {
        vsc.writeInVSC(editor, answer, vsc.WRITE_IN_SIDE_PANEL);
    }

    writeUserInputForPrompt(userInput: string): string {
        return `User says:\n"${userInput}".`;
    }
}

export class AutorunExampleCommand extends BaseWithNoUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        var suggestion = await gpt.getGptSuggestion(
            prompt,
            "You are given a piece of code and you run it as it you were the user. Write, step-by-step, what are you interacting with and what results you are getting. Be really specific with your examples, create realistic input data. Like '1. The program prints ...\n2. I type something\n3. The program prints ....\n4. I decide 'option'.\n5. The program...'"
        );
        return suggestion;
    }

    async showAnswer(editor: vscode.TextEditor, answer: string) {
        vsc.writeInVSC(editor, answer, vsc.WRITE_IN_SIDE_PANEL);
    }
}

export class AutorunSequenceCommand extends BaseWithNoUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        var suggestion = await gpt.getGptSuggestion(
            prompt,
            "You are a debugging tool installed in Visual Studio Code as an extension. You are given a piece of code and you simulate how it would run, giving details about variables values, exceptions raised, bugs and information about runtime and compilation. Write what would happen step-by-step, and, if it's a good format, enumerate each step.",
        );
        return suggestion;
    }

    async showAnswer(editor: vscode.TextEditor, answer: string) {
        vsc.writeInVSC(editor, answer, vsc.WRITE_IN_SIDE_PANEL);
    }
}

export class EsotericCommand extends BaseWithNoUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        var suggestion = await gpt.getGptSuggestion(
            prompt,
            "You are a coding tool installed in Visual Studio Code as an extension. You are given a piece of code and you will code it in: LOLCODE, Brainfuck, Chef or Shakespeare Programming Language. Just use one of them.",
        );
        return suggestion;
    }

    async showAnswer(editor: vscode.TextEditor, answer: string) {
        vsc.writeInVSC(editor, answer, vsc.WRITE_IN_SIDE_PANEL);
    }
}

export class RefactorizeCommand extends BaseWithNoUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        var suggestion = await gpt.getGptSuggestion(
            prompt,
            "You are a coding tool installed in Visual Studio Code as an extension. You are given a piece of code and you will refactorize it as clean and orderly as possible, following the clean code principles of the programming language.",
        );
        suggestion = gpt.getCodeFromModelSuggestion(suggestion);
        suggestion = gpt.cleanCodeAnswer(suggestion);
        return suggestion;
    }

    async showAnswer(editor: vscode.TextEditor, answer: string) {
        vsc.writeInVSC(editor, answer, vsc.WRITE_IN_SIDE_PANEL);
    }
}

export class DesignPatternsSuggestionsCommand extends BaseWithNoUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        var suggestion = await gpt.getGptSuggestion(
            prompt,
            "You are a coding tool installed in Visual Studio Code as an extension. You are given a piece of code and you will explain what are the best design patterns that can be applied to that code.",
        );
        return suggestion;
    }

    async showAnswer(editor: vscode.TextEditor, answer: string) {
        vsc.writeInVSC(editor, answer, vsc.WRITE_IN_SIDE_PANEL);
    }
}

export class DesignPatternCommand extends BaseWithUserInputCommand {
    async getLLMAnswerMethod(prompt: string): Promise<string> {
        var suggestion = await gpt.getGptSuggestion(
            prompt,
            "You are a coding tool installed in Visual Studio Code as an extension. You are given a piece of code and will apply the design pattern that the user specified.",
        );
        return suggestion;
    }

    async showAnswer(editor: vscode.TextEditor, answer: string): Promise<void> {
        vsc.writeInVSC(editor, answer, vsc.WRITE_IN_SIDE_PANEL);
    }

    writeUserInputForPrompt(userInput: string): string {
        return `Design pattern: ${userInput}.`;
    }
}